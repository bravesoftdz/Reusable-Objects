unit TestObj.ITax;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
    TestFramework
  , Obj.SSI.Tax
  ;

type
  // Test methods for class ICurrency

  TestITax = class(TTestCase)
  strict private
    FITax: ITax;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAsCurrencyEquals1000;
    procedure TestAsICurrencyEquals1000;
    procedure TestAsStringEqualsFormated1000;
    procedure TestAdd23percentEquals1230;
    procedure TestAdd0Equals1000;
    procedure TestSub23percentEquals813_01;
    procedure TestSub0Equals1000;
    procedure TestAddValue150Equals1150;
    procedure TestAddValue0Equals1000;
    procedure TestSubValue700Equals300;
    procedure TestSubValue0Equals1000;
  end;

implementation

uses
    SysUtils
  , Obj.SSI.Currency
  ;

procedure TestITax.SetUp;
begin
     FITax := TTax.New(1000);
end;

procedure TestITax.TearDown;
begin
     FITax := nil;
end;

procedure TestITax.TestAsCurrencyEquals1000;
var
   ExpectedValue, ReturnValue: Currency;
begin
     ExpectedValue := 1000;
     ReturnValue   := FITax.AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestAsICurrencyEquals1000;
var
   ExpectedValue, ReturnValue: Currency;
begin
     ExpectedValue := TCurrency.New(1000).AsCurrency;
     ReturnValue   := FITax.AsICurrency.AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestAsStringEqualsFormated1000;
var
   ExpectedValue, ReturnValue: string;
begin
     ExpectedValue := Format('1%s000%s00 €', [FormatSettings.ThousandSeparator, FormatSettings.DecimalSeparator]);
     ReturnValue   := FITax.AsString;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestSub0Equals1000;
var
   ExpectedValue, ReturnValue: Currency;
begin
     ExpectedValue := 1000;
     ReturnValue   := FITax.Sub(0).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestSub23percentEquals813_01;
var
   ExpectedValue, ReturnValue: Currency;
   Value: Single;
begin
     Value         := 23;
     ExpectedValue := 813.0081;
     ReturnValue   := FITax.Sub(Value).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestSubValue0Equals1000;
var
   ExpectedValue, ReturnValue: Currency;
   Value: Single;
begin
     Value         := 0;
     ExpectedValue := 1000;
     ReturnValue   := FITax.SubValue(Value).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestSubValue700Equals300;
var
   ExpectedValue, ReturnValue: Currency;
   Value: Single;
begin
     Value         := 700;
     ExpectedValue := 300;
     ReturnValue   := FITax.SubValue(Value).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestAdd23percentEquals1230;
var
   ExpectedValue, ReturnValue: Currency;
   Value: Single;
begin
     Value         := 23;
     ExpectedValue := 1230;
     ReturnValue   := FITax.Add(Value).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestAddValue0Equals1000;
var
   ExpectedValue, ReturnValue: Currency;
   Value: Single;
begin
     Value         := 0;
     ExpectedValue := 1000;
     ReturnValue   := FITax.AddValue(Value).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestAddValue150Equals1150;
var
   ExpectedValue, ReturnValue: Currency;
   Value: Single;
begin
     Value         := 150;
     ExpectedValue := 1150;
     ReturnValue   := FITax.AddValue(Value).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

procedure TestITax.TestAdd0Equals1000;
var
   ExpectedValue, ReturnValue: Currency;
begin
     ExpectedValue := 1000;
     ReturnValue   := FITax.Add(0).AsCurrency;
     CheckEquals(ExpectedValue, ReturnValue);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestITax.Suite);
end.

